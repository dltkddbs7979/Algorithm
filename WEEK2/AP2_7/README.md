# 🏗️ Tower of Hanoi

## 📄 Description  
아래와 같은 **하노이의 탑(Tower of Hanoi)** 문제를 해결하는 코드가 있다.

해당 코드에서 **K번째 이동 결과**를 출력하고, 전체적으로 `hanoi()` 함수가 **몇 번 호출되었는지**를 출력하시오.

```cpp
#include <bits/stdc++.h>
using namespace std;

void hanoi(int n, char src, char via, char dst) {
    if (n == 1) {
        printf("%c -> %c\n", src, dst);
    }
    else {
        hanoi(n-1, src, dst, via);
        hanoi(1, src, via, dst);
        hanoi(n-1, via, src, dst);
    }
}

int main() {
    int n;
    cin >> n;
    hanoi(n, 'A', 'B', 'C');
}
```

---

## 📥 Input  
- 첫째 줄에 **원반의 개수 `N`과 양의 정수 `K`**가 주어진다.  

📌 **입력 예시**  
```txt
3 4
```

---

## 📤 Output  
1. 첫째 줄에 **K번째 이동 결과**를 출력한다.
2. 둘째 줄에 `hanoi()` 함수가 **총 몇 번 호출되었는지** 출력한다.

📌 **출력 예시**  
```txt
A -> C
10
```

📌 **입력 & 출력 예시 2**  
```txt
Input:
4 8

Output:
A -> C
22
```

📌 **입력 & 출력 예시 3**  
```txt
Input:
15 4000

Output:
C -> A
49150
```

---

## 🧐 Algorithm Explanation  

### ✅ **하노이의 탑 알고리즘**
1. `n`개의 원반을 이동하는 과정은 다음과 같이 분할됨:
   - `n-1`개의 원반을 **출발 기둥(src) → 보조 기둥(via)**으로 이동
   - 가장 큰 원반을 **출발 기둥(src) → 목적 기둥(dst)**으로 이동
   - `n-1`개의 원반을 **보조 기둥(via) → 목적 기둥(dst)**으로 이동

### 🔢 **하노이 이동 횟수 공식**
- 하노이의 탑 문제에서 최소 이동 횟수는 다음과 같음:
  
  \[
  M(N) = 2^N - 1
  \]
  
  따라서, 하노이 함수 호출 횟수는 **2 × M(N) - 1**이다.

---

## ⏳ **시간 복잡도 분석**  
하노이의 탑 알고리즘의 **시간 복잡도는 O(2^N)** 이다.

✔ 최악의 경우: **O(2^N)** (지수 성장)  
✔ 원반 개수가 많아질수록 매우 빠르게 증가함  
✔ 비효율적인 알고리즘이지만, 문제의 특성상 최적화가 어려움  

---

## 📌 **특징**  
✔ **재귀 호출이 많아지는 대표적인 문제**  
✔ **2^N에 비례하는 급격한 증가**로 인해 큰 `N`에 대해서는 실행 시간이 길어질 수 있음  
✔ `K`번째 이동을 추적하기 위해 이동 순서를 저장하는 방법이 필요함  

---

