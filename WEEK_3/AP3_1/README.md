# 🔎 Binary Search

## 📌 Description  
교재/강의자료를 참고하여 **Algorithm 2.1. Recursive Binary Search**를 구현하시오.  

- 교재의 알고리즘은 **배열의 인덱스가 1부터 시작**함에 유의할 것.  
- 문제의 입력 데이터는 **정렬되지 않은 데이터**이므로, 먼저 **오름차순 정렬**을 해야 함에 유의하시오.

---

## 📥 Input  
- 첫째 줄에 배열의 크기 `N`과 찾고자 하는 원소의 개수 `M`이 주어진다.  
- 둘째 줄에 `N`개의 정수가 주어진다.  
- 셋째 줄에 `M`개의 정수가 주어진다.

### 📌 입력 예시 1
```
6 3
10 7 11 5 13 8
5 8 3
```

### 📌 입력 예시 2
```
10 5
10 9 8 7 6 5 4 3 2 1
1 10 100 5 7
```

---

## 📤 Output  
- `M`개의 줄에 걸쳐, 각 줄마다 다음 두 값을 출력한다:  
  1. `binsearch2()` 함수가 **호출된 횟수**  
  2. `binsearch2()` 함수의 **리턴 값** (탐색 성공 시 위치, 실패 시 0)

### 📌 출력 예시 1
```
2 1
1 3
3 0
```

### 📌 출력 예시 2
```
3 1
4 10
5 0
1 5
4 7
```

---

## 🧐 Algorithm Explanation

### ✅ 이진 탐색 (Recursive Binary Search)란?  
이진 탐색은 정렬된 배열에서 **중간 값을 기준으로 절반씩 탐색 범위를 줄여가며** 값을 찾는 알고리즘입니다.  
재귀 호출 방식으로 구현할 경우, 탐색 구간이 바뀔 때마다 함수가 재귀적으로 호출됩니다.

---

### 🔹 동작 원리

1. 배열을 오름차순으로 정렬한다.  
2. 배열의 중간 값을 기준으로 찾고자 하는 값과 비교한다.  
3. 같으면 해당 위치를 반환하고,  
   작으면 오른쪽 부분 배열에서,  
   크면 왼쪽 부분 배열에서 **재귀적으로 이진 탐색**을 수행한다.  
4. 이진 탐색이 호출될 때마다 횟수를 카운트하여 출력에 포함시킨다.  
5. 값을 찾지 못한 경우, 리턴 값은 0이다.

---

## ⏳ 시간 복잡도

| 경우           | 시간 복잡도       |
|----------------|------------------|
| 최악 (Worst)    | O(log N)         |
| 최선 (Best)     | O(1)             |
| 평균 (Average)  | O(log N)         |

> 단, 정렬은 `O(N log N)`이므로 전체 시간 복잡도는 `O(N log N + M log N)`.

---

## 📌 특징

✔ 배열 인덱스를 **1부터 시작**하는 이진 탐색 알고리즘 연습  
✔ 재귀 호출의 흐름과 호출 횟수 추적 훈련  
✔ 정렬되지 않은 입력 데이터를 정렬 후 탐색한다는 점에서 응용력 필요  
✔ 정렬 + 탐색이라는 전형적인 문제 패턴 훈련
